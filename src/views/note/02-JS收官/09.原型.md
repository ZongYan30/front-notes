# 原型

##  原型要解决的问题

<img src="http://mdrs.yuanjin.tech/img/20211210142340.png" alt="image-20211210142340406" style="zoom:50%;" />

上图中，通过构造函数可以创建一个用户对象

这种做法有一个严重的缺陷，就是每个用户对象中都拥有一个`sayHi`方法，对于每个用户而言，`sayHi`方法是完全一样的，没必要为每个用户单独生成一个。

```js
function Person(name,age){
    this.name=name;
    this.age=age;
    this.sayHi=()=>{
        console.log("hi");
    }
}

const u1 = new Person("张三",10);
const u2 = new Person("李四",20);//每new一次都单独开辟了一块空间，sayHi表现结果都是一样的。如果需要生成1w个对象，这就造成了内存浪费。

console.log(u1.sayHi === u2.sayHi);//false
```



要解决这个问题，必须学习原型

## 原型的三角关系

<img src="http://mdrs.yuanjin.tech/img/20211210141850.png" alt="image-20211210141850465" style="zoom:50%;" />



1. **原型**

   每个函数都会自动附带一个属性`prototype`，这个属性的值是一个普通对象，称之为原型对象

2. **实例**

   instance，通过`new`产生的对象称之为实例。

   > 由于JS中所有对象都是通过`new`产生的，因此，严格来说，JS中所有对象都称之为实例

3. **隐式原型**

   每个实例都拥有一个特殊的属性`__proto__`，称之为隐式原型，它指向构造函数的原型



这一切有何意义？

**当访问实例成员时，先找自身，如果不存在，会自动从隐式原型中寻找**

**这样一来，我们可以把那些公共成员，放到函数的原型中，即可被所有实例共享**

<img src="http://mdrs.yuanjin.tech/img/20211210143328.png" alt="image-20211210143328533" style="zoom:50%;" />

```js
function Person(name,age){
    this.name=name;
    this.age=age;
}

//将公共的方法放到原型上去
Person.prototype.sayHi = () => {
        console.log("hi");
}

const u1 = new Person("张三",10);
u1.sayHi();//优先从隐士原型__proto__上找，找不到就去原型中找。
```

这个时候，上节课的扑克牌的代码就可以优化一下，把print函数提出来放到原型上去。
在开发中，99%都会将函数放到原型上去了。

